# 函数扩展
函数这块涉及到一些新的语法，开发更便捷。但要理解透彻，比如=>函数

### 函数参数默认值
支持参数阶段设置默认值，遵循一个规则，有默认参数的，都放在后面。默认参数后面不要出现没有默认值的参数。虽然现阶段已经不会报错，浏览器已经解决了这个BUG。

**注意：** 函数参数本身就是声明，因此特别注意函数体内切勿出现let重复声明。
```js
  function test(a = 1, b = 2) {
    console.log(a,b)
  }
```

配合解构赋值默认值使用
```js
  // 这里的解构，只用到了对象解构，传入参数是一个对象，对象中属性具有默认值
  function foo({x, y = 5}) {
    console.log(x, y)
  }

  foo({}) // 正常不会报错 undefined 5
  foo() // 会报错，并没有正常解构，没有传入跟{x, y = 5} 对应的结构。而上面一个调用传入
```

```js
  function foo({x, y = 5} = {}) {
    console.log(x, y)
  }
  foo() // 这里传入空值可以，因为默认参数是空对象，而且x,y也进行了声明，且y有默认值。对比上面的函数，同时用到了对象解构和对象默认值。
```

### 函数默认参数形成作用域
```js
  let x = 1;
  function f(y = x) {
    let x = 2;
    console.log(y)
  }
  f()
```
咋一看结果好像是`2`。运行发现结果是`1`。
分析一下，`y=x`取到的是上面声明的x，有默认参数的时候，函数调用时，其参数会形成一个作用域。可以拆成这样看：
```js
  // 伪代码，仅解释函数参数形成作用域造成的影响
  let x = 1;
  {
    y = x // 这里访问外层的let x = 1。因此 y = 1
    {
      let x = 2
      console.log(y) // 1
    }
  }
```

### 函数不定参用rest参数
ES5，我们有`arguments`，可以取到函数的参数集合（并不是数组），虽然arguments已被废弃，建议不再使用。
ES6中，我们可以使用`...restVal`
